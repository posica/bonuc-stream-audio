#info@bonuc-sbc-telesale-org-roke:~$ cat /usr/share/freeswitch/scripts/stream_audio.py
# -*- coding: utf-8 -*-
#!/usr/bin/env python3
"""
[FreeSWITCH mod_python3 stream_audio - AutoStop/Retry + Backoff ç‰ˆ]
æ”¹è‰¯é‡é»ï¼š
 - ESL è‡ªå‹•é‡è©¦ 3 æ¬¡ (å« backoff)
 - uuid_audio_stream è‹¥å¤±æ•—è‡ªå‹•é‡è©¦
 - ä¿ç•™ AutoStop + Retry (bug already attached)
 - å¢å¼· debug log
"""

import json
import time
import threading
import ESL

try:
    import freeswitch
except ImportError:
    freeswitch = None

# === è¨­å®šå€ ===
ESL_HOST = "127.0.0.1"
ESL_PORT = 8021
ESL_PASS = "ClueCon"
WS_URL = "ws://192.168.0.19:5000"

MAX_ESL_RETRY = 3         # ESL é€£ç·šé‡è©¦æ¬¡æ•¸
MAX_STREAM_RETRY = 3      # éŸ³è¨Š attach é‡è©¦æ¬¡æ•¸
BACKOFF_BASE = 1          # Backoff åŸºæº–ç§’æ•¸ (1â†’2â†’4)
DEBUG = True


# === åŸºç¤å‡½å¼ ===
def _log(level, msg):
    prefix = f"[stream_audio][{level}] "
    if freeswitch:
        freeswitch.consoleLog(level, prefix + msg + "\n")
    else:
        print(prefix + msg)


# === ESL é€£ç·š (è‡ªå‹•é‡è©¦) ===
def _connect_esl(max_retry=MAX_ESL_RETRY, backoff_base=BACKOFF_BASE):
    for attempt in range(1, max_retry + 1):
        conn = ESL.ESLconnection(ESL_HOST, ESL_PORT, ESL_PASS)
        if conn.connected():
            _log("INFO", f"âœ… ESL é€£ç·šæˆåŠŸ (ç¬¬ {attempt} æ¬¡)")
            return conn
        else:
            delay = backoff_base ** attempt
            _log("WARN", f"âš ï¸ ESL é€£ç·šå¤±æ•— (ç¬¬ {attempt}/{max_retry} æ¬¡)ï¼Œ{delay}s å¾Œé‡è©¦...")
            time.sleep(delay)
    raise RuntimeError(f"âŒ ç„¡æ³•é€£ç·šåˆ° ESL ({ESL_HOST}:{ESL_PORT}) after {max_retry} attempts")


# === æ ¸å¿ƒä¸²æµå‹•ä½œ ===
def _start_audio_stream(conn, session_uuid, metadata_json):
    cmd = f"{session_uuid} start {WS_URL} stereo 8k {metadata_json}"
    for attempt in range(1, MAX_STREAM_RETRY + 1):
        _log("INFO", f"â–¶ï¸ å˜—è©¦å•Ÿå‹•éŸ³è¨Šä¸²æµ (ç¬¬ {attempt}/{MAX_STREAM_RETRY} æ¬¡): {cmd}")
        result = conn.api("uuid_audio_stream", cmd)
        reply = result.getBody().strip()
        _log("INFO", f"ğŸ§ Response: {reply}")

        if "OK" in reply or "started" in reply.lower():
            _log("INFO", f"âœ… éŸ³è¨Šä¸²æµå•Ÿå‹•æˆåŠŸ (ç¬¬ {attempt} æ¬¡)")
            return True

        if "bug already attached" in reply.lower():
            _log("WARN", "âš™ï¸ åµæ¸¬åˆ° bug already attachedï¼ŒåŸ·è¡Œ stop â†’ restart æµç¨‹")
            conn.api("uuid_audio_stream", f"{session_uuid} stop")
            time.sleep(1)
            continue  # é‡è©¦ attach

        delay = BACKOFF_BASE ** attempt
        _log("WARN", f"âš ï¸ å•Ÿå‹•å¤±æ•—ï¼Œ{delay}s å¾Œé‡è©¦...")
        time.sleep(delay)

    _log("ERR", "âŒ ç„¡æ³•å•Ÿå‹•éŸ³è¨Šä¸²æµ (å·²é”æœ€å¤§é‡è©¦æ¬¡æ•¸)")
    return False


# === ä¸»åŸ·è¡Œé‚è¼¯ ===
def _do_stream(session_uuid, trigger_source="unknown"):
    try:
        _log("INFO", f"ğŸŸ¡ é€²å…¥ _do_stream(UUID={session_uuid}, ä¾†æº={trigger_source})")

        conn = _connect_esl()
        exists = conn.api("uuid_exists", session_uuid).getBody().strip()
        if exists != "true":
            _log("WARN", f"âš ï¸ UUID {session_uuid} ä¸å­˜åœ¨ï¼Œç•¥éä¸²æµã€‚")
            return

        callstate = conn.api("uuid_getvar", f"{session_uuid} callstate").getBody().strip()
        ch_state = conn.api("uuid_getvar", f"{session_uuid} channel_state").getBody().strip()
        _log("INFO", f"ğŸ” callstate={callstate}, channel_state={ch_state}")

        # --- buglist åµæ¸¬ ---
        buglist = conn.api("uuid_buglist", session_uuid).getBody().strip()
        if "mod_audio_stream" in buglist:
            _log("WARN", "âš™ï¸ å·²åµæ¸¬åˆ°èˆŠçš„ mod_audio_stream bugï¼Œå…ˆè¡Œåœæ­¢ä¸­...")
            stop_resp = conn.api("uuid_audio_stream", f"{session_uuid} stop").getBody().strip()
            _log("INFO", f"ğŸ›‘ Stop response: {stop_resp}")
            time.sleep(1)

        # metadata
        caller_num = conn.api("uuid_getvar", f"{session_uuid} caller_id_number").getBody().strip() or "unknown"
        metadata = {
            "call_id": session_uuid,
            "language": "zh-TW",
            "caller_number": caller_num,
            "timestamp": int(time.time())
        }
        metadata_json = json.dumps(metadata, ensure_ascii=False)

        # å•Ÿå‹•éŸ³è¨Šä¸²æµ
        _start_audio_stream(conn, session_uuid, metadata_json)

    except Exception as e:
        _log("ERR", f"Exception in _do_stream: {e}")


# === FreeSWITCH handler ===
def handler(session, args):
    try:
        session_uuid = args.strip() if args else session.get_uuid()
        _log("INFO", f"ğŸ“ handler è§¸ç™¼ï¼ŒUUID={session_uuid}")
        threading.Thread(target=_do_stream, args=(session_uuid, "dialplan"), daemon=True).start()
    except Exception as e:
        _log("ERR", f"handler exception: {e}")


# === CLI/FSAPI å‘¼å«å…¥å£ ===
def fsapi(session, stream, env, args):
    _log("INFO", f"ğŸ’» fsapi è¢«å‘¼å«ï¼Œargs={args}")
    if not args:
        msg = "âŒ ç¼ºå°‘ UUIDï¼Œä¾‹å¦‚ï¼šfs_cli -x 'python stream_audio <uuid>'"
        _log("ERR", msg)
        stream.write(msg + "\n")
        return

    threading.Thread(target=_do_stream, args=(args.strip(), "fsapi"), daemon=True).start()
    stream.write("+OK stream_audio background started\n")


_log("NOTICE", "âœ… stream_audio.py å·²è¼‰å…¥ï¼ˆAutoStop + Retry + Backoff å¼·åŒ–ç‰ˆ for FS 1.10.xï¼‰")

if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("ç”¨æ³•ï¼špython3 stream_audio.py <uuid>")
        sys.exit(1)
    uuid = sys.argv[1]
    _log("INFO", f"ğŸ§ª æ‰‹å‹•æ¸¬è©¦æ¨¡å¼å•Ÿå‹•ï¼ŒUUID={uuid}")
    threading.Thread(target=_do_stream, args=(uuid, "manual"), daemon=True).start()
    time.sleep(2)
    _log("INFO", "âœ… èƒŒæ™¯ä»»å‹™å·²å•Ÿå‹•ã€‚")
